// Generated by gencpp from file V2X_Integration/BSM.msg
// DO NOT EDIT!


#ifndef V2X_INTEGRATION_MESSAGE_BSM_H
#define V2X_INTEGRATION_MESSAGE_BSM_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace V2X_Integration
{
template <class ContainerAllocator>
struct BSM_
{
  typedef BSM_<ContainerAllocator> Type;

  BSM_()
    : id()
    , sec_mark(0.0)
    , message_count(0)
    , latitude(0.0)
    , longtitude(0.0)
    , elevation(0.0)
    , pos_accuracy_semi_major(0.0)
    , pos_accuracy_semi_minor(0.0)
    , pos_accuracy_orientation(0.0)
    , lateral_acceleration(0.0)
    , longitudinal_acceleration(0.0)
    , vert_acceleration(0.0)
    , yaw_acceleration(0.0)
    , transmission_state(0)
    , response_type(0)
    , light_use(0)
    , siren_use(0)
    , events(0)
    , lights(0)
    , confidence_position(0)
    , confidence_elevation(0)
    , vehicle_class(0)
    , vehicle_fuel_type(0)
    , heading(0.0)
    , speed(0.0)
    , angle(0)
    , vehicle_width(0.0)
    , vehicle_lenth(0.0)
    , vehicle_height(0.0)
    , brake_padel(0)
    , wheel_brakes(0)
    , traction(0)
    , abs(0)
    , scs(0)
    , brake_boost(0)
    , aux_brakes(0)  {
    }
  BSM_(const ContainerAllocator& _alloc)
    : id(_alloc)
    , sec_mark(0.0)
    , message_count(0)
    , latitude(0.0)
    , longtitude(0.0)
    , elevation(0.0)
    , pos_accuracy_semi_major(0.0)
    , pos_accuracy_semi_minor(0.0)
    , pos_accuracy_orientation(0.0)
    , lateral_acceleration(0.0)
    , longitudinal_acceleration(0.0)
    , vert_acceleration(0.0)
    , yaw_acceleration(0.0)
    , transmission_state(0)
    , response_type(0)
    , light_use(0)
    , siren_use(0)
    , events(0)
    , lights(0)
    , confidence_position(0)
    , confidence_elevation(0)
    , vehicle_class(0)
    , vehicle_fuel_type(0)
    , heading(0.0)
    , speed(0.0)
    , angle(0)
    , vehicle_width(0.0)
    , vehicle_lenth(0.0)
    , vehicle_height(0.0)
    , brake_padel(0)
    , wheel_brakes(0)
    , traction(0)
    , abs(0)
    , scs(0)
    , brake_boost(0)
    , aux_brakes(0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _id_type;
  _id_type id;

   typedef float _sec_mark_type;
  _sec_mark_type sec_mark;

   typedef int16_t _message_count_type;
  _message_count_type message_count;

   typedef float _latitude_type;
  _latitude_type latitude;

   typedef float _longtitude_type;
  _longtitude_type longtitude;

   typedef float _elevation_type;
  _elevation_type elevation;

   typedef float _pos_accuracy_semi_major_type;
  _pos_accuracy_semi_major_type pos_accuracy_semi_major;

   typedef float _pos_accuracy_semi_minor_type;
  _pos_accuracy_semi_minor_type pos_accuracy_semi_minor;

   typedef float _pos_accuracy_orientation_type;
  _pos_accuracy_orientation_type pos_accuracy_orientation;

   typedef float _lateral_acceleration_type;
  _lateral_acceleration_type lateral_acceleration;

   typedef float _longitudinal_acceleration_type;
  _longitudinal_acceleration_type longitudinal_acceleration;

   typedef float _vert_acceleration_type;
  _vert_acceleration_type vert_acceleration;

   typedef float _yaw_acceleration_type;
  _yaw_acceleration_type yaw_acceleration;

   typedef uint8_t _transmission_state_type;
  _transmission_state_type transmission_state;

   typedef uint8_t _response_type_type;
  _response_type_type response_type;

   typedef uint8_t _light_use_type;
  _light_use_type light_use;

   typedef uint8_t _siren_use_type;
  _siren_use_type siren_use;

   typedef uint8_t _events_type;
  _events_type events;

   typedef uint8_t _lights_type;
  _lights_type lights;

   typedef uint8_t _confidence_position_type;
  _confidence_position_type confidence_position;

   typedef uint8_t _confidence_elevation_type;
  _confidence_elevation_type confidence_elevation;

   typedef uint8_t _vehicle_class_type;
  _vehicle_class_type vehicle_class;

   typedef uint8_t _vehicle_fuel_type_type;
  _vehicle_fuel_type_type vehicle_fuel_type;

   typedef float _heading_type;
  _heading_type heading;

   typedef float _speed_type;
  _speed_type speed;

   typedef int16_t _angle_type;
  _angle_type angle;

   typedef float _vehicle_width_type;
  _vehicle_width_type vehicle_width;

   typedef float _vehicle_lenth_type;
  _vehicle_lenth_type vehicle_lenth;

   typedef float _vehicle_height_type;
  _vehicle_height_type vehicle_height;

   typedef uint8_t _brake_padel_type;
  _brake_padel_type brake_padel;

   typedef uint8_t _wheel_brakes_type;
  _wheel_brakes_type wheel_brakes;

   typedef uint8_t _traction_type;
  _traction_type traction;

   typedef uint8_t _abs_type;
  _abs_type abs;

   typedef uint8_t _scs_type;
  _scs_type scs;

   typedef uint8_t _brake_boost_type;
  _brake_boost_type brake_boost;

   typedef uint8_t _aux_brakes_type;
  _aux_brakes_type aux_brakes;





  typedef boost::shared_ptr< ::V2X_Integration::BSM_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::V2X_Integration::BSM_<ContainerAllocator> const> ConstPtr;

}; // struct BSM_

typedef ::V2X_Integration::BSM_<std::allocator<void> > BSM;

typedef boost::shared_ptr< ::V2X_Integration::BSM > BSMPtr;
typedef boost::shared_ptr< ::V2X_Integration::BSM const> BSMConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::V2X_Integration::BSM_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::V2X_Integration::BSM_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::V2X_Integration::BSM_<ContainerAllocator1> & lhs, const ::V2X_Integration::BSM_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.sec_mark == rhs.sec_mark &&
    lhs.message_count == rhs.message_count &&
    lhs.latitude == rhs.latitude &&
    lhs.longtitude == rhs.longtitude &&
    lhs.elevation == rhs.elevation &&
    lhs.pos_accuracy_semi_major == rhs.pos_accuracy_semi_major &&
    lhs.pos_accuracy_semi_minor == rhs.pos_accuracy_semi_minor &&
    lhs.pos_accuracy_orientation == rhs.pos_accuracy_orientation &&
    lhs.lateral_acceleration == rhs.lateral_acceleration &&
    lhs.longitudinal_acceleration == rhs.longitudinal_acceleration &&
    lhs.vert_acceleration == rhs.vert_acceleration &&
    lhs.yaw_acceleration == rhs.yaw_acceleration &&
    lhs.transmission_state == rhs.transmission_state &&
    lhs.response_type == rhs.response_type &&
    lhs.light_use == rhs.light_use &&
    lhs.siren_use == rhs.siren_use &&
    lhs.events == rhs.events &&
    lhs.lights == rhs.lights &&
    lhs.confidence_position == rhs.confidence_position &&
    lhs.confidence_elevation == rhs.confidence_elevation &&
    lhs.vehicle_class == rhs.vehicle_class &&
    lhs.vehicle_fuel_type == rhs.vehicle_fuel_type &&
    lhs.heading == rhs.heading &&
    lhs.speed == rhs.speed &&
    lhs.angle == rhs.angle &&
    lhs.vehicle_width == rhs.vehicle_width &&
    lhs.vehicle_lenth == rhs.vehicle_lenth &&
    lhs.vehicle_height == rhs.vehicle_height &&
    lhs.brake_padel == rhs.brake_padel &&
    lhs.wheel_brakes == rhs.wheel_brakes &&
    lhs.traction == rhs.traction &&
    lhs.abs == rhs.abs &&
    lhs.scs == rhs.scs &&
    lhs.brake_boost == rhs.brake_boost &&
    lhs.aux_brakes == rhs.aux_brakes;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::V2X_Integration::BSM_<ContainerAllocator1> & lhs, const ::V2X_Integration::BSM_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace V2X_Integration

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::V2X_Integration::BSM_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::V2X_Integration::BSM_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::V2X_Integration::BSM_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::V2X_Integration::BSM_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::V2X_Integration::BSM_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::V2X_Integration::BSM_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::V2X_Integration::BSM_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e6940b8bdce7382d047211cc39f10e12";
  }

  static const char* value(const ::V2X_Integration::BSM_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe6940b8bdce7382dULL;
  static const uint64_t static_value2 = 0x047211cc39f10e12ULL;
};

template<class ContainerAllocator>
struct DataType< ::V2X_Integration::BSM_<ContainerAllocator> >
{
  static const char* value()
  {
    return "V2X_Integration/BSM";
  }

  static const char* value(const ::V2X_Integration::BSM_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::V2X_Integration::BSM_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string id\n"
"float32 sec_mark\n"
"int16 message_count\n"
"float32 latitude\n"
"float32 longtitude\n"
"float32 elevation\n"
"float32 pos_accuracy_semi_major\n"
"float32 pos_accuracy_semi_minor\n"
"float32 pos_accuracy_orientation\n"
"float32 lateral_acceleration\n"
"float32 longitudinal_acceleration\n"
"float32 vert_acceleration\n"
"float32 yaw_acceleration\n"
"uint8 transmission_state\n"
"uint8 response_type\n"
"uint8 light_use\n"
"uint8 siren_use\n"
"uint8 events\n"
"uint8 lights\n"
"uint8 confidence_position\n"
"uint8 confidence_elevation\n"
"uint8 vehicle_class\n"
"uint8 vehicle_fuel_type\n"
"float32 heading\n"
"float32 speed\n"
"int16 angle\n"
"float32 vehicle_width\n"
"float32 vehicle_lenth\n"
"float32 vehicle_height\n"
"uint8 brake_padel\n"
"uint8 wheel_brakes\n"
"uint8 traction\n"
"uint8 abs\n"
"uint8 scs\n"
"uint8 brake_boost\n"
"uint8 aux_brakes\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
;
  }

  static const char* value(const ::V2X_Integration::BSM_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::V2X_Integration::BSM_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.sec_mark);
      stream.next(m.message_count);
      stream.next(m.latitude);
      stream.next(m.longtitude);
      stream.next(m.elevation);
      stream.next(m.pos_accuracy_semi_major);
      stream.next(m.pos_accuracy_semi_minor);
      stream.next(m.pos_accuracy_orientation);
      stream.next(m.lateral_acceleration);
      stream.next(m.longitudinal_acceleration);
      stream.next(m.vert_acceleration);
      stream.next(m.yaw_acceleration);
      stream.next(m.transmission_state);
      stream.next(m.response_type);
      stream.next(m.light_use);
      stream.next(m.siren_use);
      stream.next(m.events);
      stream.next(m.lights);
      stream.next(m.confidence_position);
      stream.next(m.confidence_elevation);
      stream.next(m.vehicle_class);
      stream.next(m.vehicle_fuel_type);
      stream.next(m.heading);
      stream.next(m.speed);
      stream.next(m.angle);
      stream.next(m.vehicle_width);
      stream.next(m.vehicle_lenth);
      stream.next(m.vehicle_height);
      stream.next(m.brake_padel);
      stream.next(m.wheel_brakes);
      stream.next(m.traction);
      stream.next(m.abs);
      stream.next(m.scs);
      stream.next(m.brake_boost);
      stream.next(m.aux_brakes);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct BSM_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::V2X_Integration::BSM_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::V2X_Integration::BSM_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.id);
    s << indent << "sec_mark: ";
    Printer<float>::stream(s, indent + "  ", v.sec_mark);
    s << indent << "message_count: ";
    Printer<int16_t>::stream(s, indent + "  ", v.message_count);
    s << indent << "latitude: ";
    Printer<float>::stream(s, indent + "  ", v.latitude);
    s << indent << "longtitude: ";
    Printer<float>::stream(s, indent + "  ", v.longtitude);
    s << indent << "elevation: ";
    Printer<float>::stream(s, indent + "  ", v.elevation);
    s << indent << "pos_accuracy_semi_major: ";
    Printer<float>::stream(s, indent + "  ", v.pos_accuracy_semi_major);
    s << indent << "pos_accuracy_semi_minor: ";
    Printer<float>::stream(s, indent + "  ", v.pos_accuracy_semi_minor);
    s << indent << "pos_accuracy_orientation: ";
    Printer<float>::stream(s, indent + "  ", v.pos_accuracy_orientation);
    s << indent << "lateral_acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.lateral_acceleration);
    s << indent << "longitudinal_acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.longitudinal_acceleration);
    s << indent << "vert_acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.vert_acceleration);
    s << indent << "yaw_acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_acceleration);
    s << indent << "transmission_state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.transmission_state);
    s << indent << "response_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.response_type);
    s << indent << "light_use: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.light_use);
    s << indent << "siren_use: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.siren_use);
    s << indent << "events: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.events);
    s << indent << "lights: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lights);
    s << indent << "confidence_position: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.confidence_position);
    s << indent << "confidence_elevation: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.confidence_elevation);
    s << indent << "vehicle_class: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vehicle_class);
    s << indent << "vehicle_fuel_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vehicle_fuel_type);
    s << indent << "heading: ";
    Printer<float>::stream(s, indent + "  ", v.heading);
    s << indent << "speed: ";
    Printer<float>::stream(s, indent + "  ", v.speed);
    s << indent << "angle: ";
    Printer<int16_t>::stream(s, indent + "  ", v.angle);
    s << indent << "vehicle_width: ";
    Printer<float>::stream(s, indent + "  ", v.vehicle_width);
    s << indent << "vehicle_lenth: ";
    Printer<float>::stream(s, indent + "  ", v.vehicle_lenth);
    s << indent << "vehicle_height: ";
    Printer<float>::stream(s, indent + "  ", v.vehicle_height);
    s << indent << "brake_padel: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_padel);
    s << indent << "wheel_brakes: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wheel_brakes);
    s << indent << "traction: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.traction);
    s << indent << "abs: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.abs);
    s << indent << "scs: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.scs);
    s << indent << "brake_boost: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_boost);
    s << indent << "aux_brakes: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.aux_brakes);
  }
};

} // namespace message_operations
} // namespace ros

#endif // V2X_INTEGRATION_MESSAGE_BSM_H
